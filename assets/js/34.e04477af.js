(window.webpackJsonp=window.webpackJsonp||[]).push([[34],{433:function(_,t,v){"use strict";v.r(t);var a=v(2),r=Object(a.a)({},(function(){var _=this,t=_._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":_.$parent.slotKey}},[t("h1",{attrs:{id:"tcp-udp-ip"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#tcp-udp-ip"}},[_._v("#")]),_._v(" TCP,UDP,IP")]),_._v(" "),t("h2",{attrs:{id:"ip-把数据包送达目的主机"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#ip-把数据包送达目的主机"}},[_._v("#")]),_._v(" IP：把数据包送达目的主机")]),_._v(" "),t("p",[_._v("计算机的地址就称为 IP 地址，访问任何网站实际上只是你的计算机向另外一台计算机请求信息。")]),_._v(" "),t("h2",{attrs:{id:"udp-把数据包送达应用程序"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#udp-把数据包送达应用程序"}},[_._v("#")]),_._v(" UDP：把数据包送达应用程序")]),_._v(" "),t("p",[_._v("“用户数据包协议（User Datagram Protocol）”，简称 UDP。\n所以 IP 通过 IP 地址信息把数据包发送给指定的电脑，而 UDP 通过端口号把数据包分发给正确的程序。和 IP 头一样，端口号会被装进 UDP 头里面，UDP 头再和原始数据包合并组成新的 UDP 数据包。UDP 头中除了目的端口，还有源端口号等信息。")]),_._v(" "),t("blockquote",[t("p",[_._v("虽然 UDP 可以校验数据是否正确，但是对于错误的数据包，UDP 并不提供重发机制，只是丢弃当前的包，而且 UDP 在发送之后也无法知道是否能达到目的地。")])]),_._v(" "),t("p",[_._v("虽说 UDP 不能保证数据可靠性，但是传输速度却非常快，所以 UDP 会应用在一些关注速度、但不那么严格要求数据完整性的领域，如在线视频、互动游戏等。\n"),t("img",{attrs:{src:"https://img2018.cnblogs.com/blog/1290987/201906/1290987-20190629165851878-1198531256.png",alt:"image"}})]),_._v(" "),t("h2",{attrs:{id:"tcp-把数据完整地送达应用程序"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#tcp-把数据完整地送达应用程序"}},[_._v("#")]),_._v(" TCP：把数据完整地送达应用程序")]),_._v(" "),t("p",[t("strong",[_._v("TCP（Transmission Control Protocol，传输控制协议）是一种面向连接的、可靠的、基于字节流的传输层通信协议")]),_._v("。\n相对于 UDP，TCP 有下面两个特点:\n对于数据包丢失的情况，TCP 提供重传机制；\nTCP 引入了数据包排序机制，用来保证把乱序的数据包组合成一个完整的文件。\n"),t("img",{attrs:{src:"https://img2018.cnblogs.com/blog/1290987/201906/1290987-20190615111551823-1173939851.png",alt:"image"}})]),_._v(" "),t("h2",{attrs:{id:"可靠性传输原理"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#可靠性传输原理"}},[_._v("#")]),_._v(" 可靠性传输原理")]),_._v(" "),t("p",[_._v("TCP主要提供了"),t("code",[_._v("检验和")]),_._v("、"),t("code",[_._v("序列号/确认应答")]),_._v("、"),t("code",[_._v("超时重传")]),_._v("、"),t("code",[_._v("流量控制(滑动窗口)")]),_._v("、"),t("code",[_._v("拥塞控制")]),_._v("等方法实现了可靠性传输。(记住5种)")]),_._v(" "),t("blockquote",[t("p",[_._v("滑动窗口协议与自动重传请求技术结合形成连续ARQ协议，连续ARQ协议根据超时重发数据方式的不同分为后退N帧ARQ协议和选择重发ARQ协议。")])]),_._v(" "),t("h3",{attrs:{id:"_1-检验和"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-检验和"}},[_._v("#")]),_._v(" 1.检验和")]),_._v(" "),t("p",[_._v("TCP 将保持它首部和数据的检验和。这是一个端到端的检验和，目的是检测数据在传输过程中的任何变化。如果收到段的检验和有差错，TCP 将丢弃这个报文段和不确认收到此报文段。")]),_._v(" "),t("h3",{attrs:{id:"_2-序列号-确认应答"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-序列号-确认应答"}},[_._v("#")]),_._v(" 2.序列号/确认应答")]),_._v(" "),t("ul",[t("li",[t("p",[t("strong",[_._v("什么是序列号？")]),_._v("\nTCP会对每个字节的数据都进行编号，数据的编号就是数据的序列号，每个字节都有自己独一无二的编号，故序列号具有唯一性")])]),_._v(" "),t("li",[t("p",[t("strong",[_._v("序列号的作用？")]),_._v("\n接收端为了区别重复的报文段（报文段也叫帧），接收端有时会收到很多重复的数据，那么TCP协议就需要能够识别出那些是重复的包，并且把重复的丢弃掉，此时就需要使用序列号，来实现去重")])]),_._v(" "),t("li",[t("p",[t("strong",[_._v("什么是确认应答机制")]),_._v("\n收到一条报文后，向发送端发送一条确认ACK，此ACK的作用就是告诉发送端：接收端已经成功的收到了消息，并且希望收到下一条报文的序列号是什么")])]),_._v(" "),t("li",[t("p",[t("strong",[_._v("为什么需要确认应答机制")]),_._v("\n在TCP连接成功后，发送的每一条数据都可能会丢失，因此需要确认应答，以保证数据的完整性")])]),_._v(" "),t("li",[t("p",[t("strong",[_._v("确认应答的作用")]),_._v("\n1.来确认接收端收到数据了\n2.可以知道收到的是哪一条数据")])])]),_._v(" "),t("h3",{attrs:{id:"_3-超时重传"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3-超时重传"}},[_._v("#")]),_._v(" 3.超时重传")]),_._v(" "),t("p",[_._v("当 TCP 发出一个段后，它启动一个定时器，等待目的端确认收到这个报文段。如果不能及时收到一个确认，将重发这个报文段。\nTCP为了保证无论在任何环境下都能比较高性能的通信，会动态的计算这个最大超时时间，所以超时时间不是确定的，是TCP动态的计算的\n超时重传时间 RTO 的值应该略大于报文往返 RTT 的值\n超时触发重传存在的问题是，超时周期可能相对较长。有没有一种机制可以减少超时重传的等待时间呢？于是 「快速重传」 机制应运而生\n"),t("strong",[_._v("快速重传")]),_._v("（Fast Retransmit）机制不以时间为驱动，而是以数据驱动重传。")]),_._v(" "),t("p",[_._v("快速重传机制的原理：每当接收方收到比期望序号大的失序报文段到达时，就向发送方发送一个冗余 ACK，指明下一个期待字节的序号。")]),_._v(" "),t("h3",{attrs:{id:"_4-流量控制"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_4-流量控制"}},[_._v("#")]),_._v(" 4.流量控制")]),_._v(" "),t("p",[_._v("流量控制解决的是发送方和接收方速率不匹配的问题;\n"),t("code",[_._v("接收方")]),_._v("通过告诉"),t("code",[_._v("发送方")]),_._v("自己接收缓冲区的大小，来使"),t("code",[_._v("发送方")]),_._v("控制发送的数据量。")]),_._v(" "),t("p",[_._v("接收端会在发送 ACK 确认应答报文时，将自己的即时窗口大小（接收窗口 rwnd）填入，并跟随 ACK 报文一起发送出去。而发送方根据接收到的 ACK 报文中的窗口大小的值改变自己的发送速度。如果接收到窗口大小的值为 0，那么发送方将停止发送数据。并定期地向接收端发送窗口探测数据段，提醒接收端把窗口大小告诉发送端。")]),_._v(" "),t("h4",{attrs:{id:"累积确认"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#累积确认"}},[_._v("#")]),_._v(" 累积确认")]),_._v(" "),t("p",[_._v("假设窗口大小为 3 个 TCP 段，那么发送方就可以「连续发送」 3 个 TCP 段，并且中途即使有 ACK响应报文丢失，也可以通过「下一个确认应答进行确认」。")]),_._v(" "),t("p",[_._v("如下图：ACK 300 即使丢失了，也不会进行数据重发，可以通过下一个确认应答进行确认。只要发送方收到了 ACK 400 的确认应答，就意味着 400 之前的所有数据「接收方」都收到了。这个模式就叫"),t("strong",[_._v("累积确认")]),_._v("或者"),t("strong",[_._v("累积应答")]),_._v("。\n"),t("img",{attrs:{src:"https://pic3.zhimg.com/80/v2-61957f3a61bc7ef342e6e39496bc010a_720w.jpg",alt:"image"}})]),_._v(" "),t("h4",{attrs:{id:"滑动窗口"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#滑动窗口"}},[_._v("#")]),_._v(" 滑动窗口")]),_._v(" "),t("ul",[t("li",[_._v("允许发送方在停止并等待确认前连续发送多个分组，而不必每发送一个分组就停下来等待确认，从而增加数据传输的速率提高应用的吞吐量。")]),_._v(" "),t("li",[_._v("实现了TCP的流量控制，不至于发送太快导致太多的数据丢弃和重传。")])]),_._v(" "),t("p",[_._v("窗口大小就是指无需等待确认应答，可以继续发送数据的最大值。\n窗口的实现实际上是操作系统开辟的一个缓冲区，发送方在等待确认应答报文返回之前，必须在缓冲区中保留已发送的数据。如果在规定时间间隔内收到确认应答报文，就可以将数据从缓冲区中清除。")]),_._v(" "),t("ol",[t("li",[_._v("发送方的窗口，下图就是发送方缓存的数据，根据处理的情况分成四个部分：")])]),_._v(" "),t("p",[_._v("已发送并收到 ACK 确认应答的数据\n已发送但未收到 ACK 确认应答的数据\n未发送但总大小在接收方处理范围内的数据\n未发送但总大小超过接收方处理范围的数据")]),_._v(" "),t("p",[t("img",{attrs:{src:"https://pic1.zhimg.com/80/v2-844ed69f04a53c75d04be1bfc98216cc_720w.jpg",alt:"image"}}),_._v("\n2. 接收方的滑动窗口\n接收方的滑动窗口可分为三个部分：")]),_._v(" "),t("p",[_._v("已成功接收并确认的数据\n未收到数据但可以接收的数据\n未收到数据且不可以接收的数据（超出接收方窗口大小）\n"),t("img",{attrs:{src:"https://pic1.zhimg.com/80/v2-48652862eeff25d1f86b51560a6fbc18_720w.jpg",alt:"image"}})]),_._v(" "),t("p",[_._v("同样的，接收方的滑动窗口在成功接收并确认的数据后，窗口右移。")]),_._v(" "),t("h3",{attrs:{id:"_5-拥塞控制"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_5-拥塞控制"}},[_._v("#")]),_._v(" 5.拥塞控制")]),_._v(" "),t("p",[_._v("拥塞控制解决的是避免网络资源被耗尽的问题。")]),_._v(" "),t("blockquote",[t("p",[_._v("当出现拥塞时，应当控制发送方的速率。这一点和流量控制很像，但是出发点不同。\n流量控制是为了让接收方能来得及接收，而拥塞控制是为了降低整个网络的拥塞程度，防止过多的数据注入到网络中。")])]),_._v(" "),t("p",[t("strong",[_._v("拥塞窗口")]),_._v("是发送方维护的一个状态变量，它会根据网络的拥塞程度动态变化。\n引入拥塞窗口cwnd后，发送窗口的大小就等于拥塞窗口和接收窗口的"),t("strong",[_._v("最小值")]),_._v("。")]),_._v(" "),t("p",[_._v("拥塞控制的几个重要的概念："),t("strong",[_._v("慢启动、拥塞避免、快恢复、快重传")])]),_._v(" "),t("p",[_._v("无论是慢开始阶段还是拥塞避免，只要出现了网络拥塞（触发超时重传机制），慢开始轮限 sshresh 和 拥塞窗口大小 cwnd 的值会发生变化（乘法减小）：")]),_._v(" "),t("p",[_._v("ssthresh 设为 cwnd/2\ncwnd 重置为 1\n由于拥塞窗口大小重置为 1 了，所以就会重新开始执行慢启动算法。\n"),t("img",{attrs:{src:"https://pic1.zhimg.com/80/v2-2b7564e5af3e189a137d50125231f50c_720w.jpg",alt:"image"}})]),_._v(" "),t("h2",{attrs:{id:"三次握手"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#三次握手"}},[_._v("#")]),_._v(" 三次握手")]),_._v(" "),t("p",[_._v("第一次：客户端给服务端发送一个带有SYN标志的数据包 第二次：服务端给客户端发送带有SYN和ACK标志得数据包 第三次：客户端给服务端发送带有ACK标志的数据包")]),_._v(" "),t("h2",{attrs:{id:"四次挥手"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#四次挥手"}},[_._v("#")]),_._v(" 四次挥手")]),_._v(" "),t("p",[_._v("因为TCP是全双工通信的")]),_._v(" "),t("p",[_._v("（1）第一次挥手")]),_._v(" "),t("p",[_._v("因此当主动方发送断开连接的请求（即FIN报文）给被动方时，仅仅代表主动方不会再发送数据报文了，但主动方仍可以接收数据报文。")]),_._v(" "),t("p",[_._v("（2）第二次挥手")]),_._v(" "),t("p",[_._v("被动方此时有可能还有相应的数据报文需要发送，因此需要先发送ACK报文，告知主动方“我知道你想断开连接的请求了”。这样主动方便不会"),t("strong",[_._v("因为没有收到应答而继续发送断开连接的请求")]),_._v("（即FIN报文）。")]),_._v(" "),t("p",[_._v("（3）第三次挥手")]),_._v(" "),t("p",[_._v("被动方在处理完数据报文后，便发送给主动方FIN报文；这样可以保证数据通信正常可靠地完成。发送完FIN报文后，被动方进入LAST_ACK阶段（超时等待）。")]),_._v(" "),t("p",[_._v("（4）第四挥手")]),_._v(" "),t("p",[_._v("如果主动方及时发送ACK报文进行连接中断的确认，这时被动方就直接释放连接，进入可用状态。（不然被动方不知道你收到没有就会一直重发）")]),_._v(" "),t("p",[_._v("参考文章\n"),t("a",{attrs:{href:"https://codeantenna.com/a/dBg3Y29JWB",target:"_blank",rel:"noopener noreferrer"}},[_._v("https://codeantenna.com/a/dBg3Y29JWB"),t("OutboundLink")],1),_._v(" "),t("a",{attrs:{href:"https://zhuanlan.zhihu.com/p/343398180",target:"_blank",rel:"noopener noreferrer"}},[_._v("https://zhuanlan.zhihu.com/p/343398180"),t("OutboundLink")],1)])])}),[],!1,null,null,null);t.default=r.exports}}]);